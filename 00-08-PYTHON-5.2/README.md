## Задачи из юнитов модуля PYTHON-5.2 (Функции) ##

#### **Задание 2.5** ####

Написать функцию-копилку `saver()`, которая не принимает никаких аргументов. Она
должна возвращать внутреннюю функцию `adder()`, которая принимает на вход одно
число и возвращает сумму в копилке после прибавления числа. Изначально в новой
копилке хранится 0.

```python
def saver():
    pot = 0
    def adder(num):
        nonlocal pot
        pot += num
        return pot
    return adder


pig = saver()
print(pig(25))
# 25
print(pig(100))
# 125
print(pig(19))
# 144
```

----

#### **Задание 3.4** ####

Написать рекурсивную функцию `multiply_lst()`, которая перемножает элементы
заданного списка между собой.

```python
def multiply_lst():
    if len(lst) == 0:
        return 1
    return lst[0] * multiply_lst(lst[1:])
```

----

#### **Задание 3.7** ####

Числа Фибоначчи&nbsp;&mdash; пример последовательности, которую можно получить
рекурсивно.    
Первые числа этой последовательности: `0, 1, 1, 2, 3, 5, 8, 13...` Каждый `n`-ый
элемент&nbsp;&mdash; это сумма `n-1` и `n-2` элементов.    
Можно записать рекурсивное выражение для расчёта `n`-ого числа из
последовательности Фибоначчи: `a[n] = a[n-1] + a[n-2]`.    
Написать рекурсивную функцию `fib(n)`, которая считает `n`-ое число Фибоначчи.
Считать, что `fib(0) = 0` и `fib(1) = 1`.

```python
def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fib(n-1) + fib(n-2)
```

----

#### **Задание 4.5** ####

Написать рекурсивную функцию `power(val, n)`, которая возводит число в заданную
целую натуральную степень (или в степень 0).    
Использовать встроенный оператор `**` для возведения в степень запрещено.
Пользоваться только умножением `*`. Например,
`2 ** 4 = (((2 * 2) * 2) * 2) = 16`.    
В качестве первого аргумента функция принимает число, в качестве
второго&nbsp;&mdash; желаемую степень.    
***Примечание***    
В качестве базовых случаев для рекурсии принять условие, что любое число в
степени&nbsp;0&nbsp;&mdash; **`1`**, любое число в степени&nbsp;1&nbsp;&mdash;
это же число.    
***Подсказка***    
Рекурсивная формула для вычисления степени от числа `val`:    
`val**(n) = val * val**(n-1)`
Таким образом, число в степени `n` равно произведению этого числа на число в
степени `n-1`.

```python
def power(val, n):
    if n == 0:
        return 1
    elif n == 1:
        return val
    else:
        return val * power(val, n-1)
```

----

#### **Задание 4.6** ####

Написать функцию `is_leap(year)`, которая принимает на вход год и возвращает
`True`, если год високосный, иначе&nbsp;&mdash; `False`.    
Условие для проверки на високосность: год делится на 400 или год делится на 4,
но не на 100.    
***Подсказка***    
В теле функции задать три условия: год нацело делится на 400, 100 и 4. Если
выполняется первое и последнее условие, функция возвращает `True`, если не
выполняется второе условие или не выполняется ни одно из перечисленных условий,
функция возвращает `False`.

```python
def is_leap(year):
    if year % 400 == 0:
        return True
    elif year % 100 == 0:
        return False
    elif year % 4 == 0:
        return True
    else:
        return False
```

----

#### **Задание 4.7** ####

При разработке пользовательского интерфейса и программ, взаимодействующих с
человеком, очень важна проверка корректности введённых пользователем данных.
Такую проверку в сообществе программистов принято называть &laquo;проверкой на
дурака&raquo;.    
Некорректно введённые данные могут &laquo;сломать&raquo; программу, если она не
была подготовлена для их обработки.    
Написать функцию `check_date(day, month, year)`, которая проверяет корректность
даты рождения по следующим условиям:

1. Все аргументы должны быть целыми числами (проверить с помощью
`type(day) is int`).
2. Годом рождения не может быть год до 1900 и год после 2022.
3. Номер месяца не может быть больше 12 и меньше 1.
4. Номер дня не может быть больше 31 и меньше 1.
5. В сентябре, апреле, июне и ноябре 30 дней.
6. Если год является високосным, то в феврале (второй месяц) должно быть 29
дней, в противном случае&nbsp;&mdash; 28.

Если дата корректна, вернуть `True`, если же хотя бы одно из представленных
условий не было выполнено&nbsp;&mdash; `False`.    
***Примечание***    
Использовать встроенные модули для работы с датами нельзя.    
Функция `check_date` должна содержать в себе функцию `is_leap` из предыдущего
задания. В теле внешней функции надо вызывать внутреннюю, чтобы проверить,
является ли год високосным.    
***Подсказка***    
В теле функции задать условия в изложенном порядке.    
Апрель, июнь, сентябрь и ноябрь&nbsp;&mdash; это четвёртый, шестой, девятый и
одиннадцатый месяц соответственно. Если заданный месяц находится в списке из
этих четырёх чисел, проверять, что указанный день не меньше 1 и не больше 30.

[**`task_4.7.py`**](task_4.7.py)

```python
print(check_date(18,9,1999))
# True
print(check_date(29,2,2000))
# True
print(check_date(29,2,2021))
# False
print(check_date(13,13,2021))
# False
print(check_date(13.5,12,2021))
# False
```

----

#### **Задание 4.8** ####

При создании приложения, предусматривающего регистрацию пользователей, надо
реализовать небольшой функционал регистрации. Не забыть также про
&laquo;проверку на дурака&raquo;.    
Написать функцию `register(surname, name, date, middle_name, registry)`.    
Функция имеет следующие аргументы:

1. `surname`&nbsp;&mdash; фамилия
2. `name`&nbsp;&mdash; имя
3. `date`&nbsp;&mdash; дата рождения (в виде кортежа из трёх чисел&nbsp;&mdash;
день, месяц, год)
4. `middle_name`&nbsp;&mdash; отчество
5. `registry`&nbsp;&mdash; список, в который необходимо добавить полученные
аргументы в виде кортежа в следующем порядке: фамилия, имя, отчество, день,
месяц, год рождения.

Функция должна возвращать список, в который добавила запись.    
***Указание***    
Сделать отчество аргументом по умолчанию со значением `None`, так как отчество
может быть не у всех регистрирующихся.    
Также сделать так, чтобы пустой список создавался в том случае, если он не был
передан извне. Таким образом, по умолчанию `registry` имеет значение `None`, и
если при вызове функции список так и не был передан, он создаётся в теле
функции.    
Наконец, проверить дату на корректность. Если дата неправильная, вернуть ошибку
`ValueError("Invalid Date!")`. Для этого пригодится функция `check_date` из
предыдущего задания.    
***Подсказка***    
Чтобы вызвать исключение, используется ключевое слово `raise ValueError()`. В
аргументы исключения передаётся требуемая строка.

[**`task_4.8.py`**](task_4.8.py)

```python
reg = register('Petrova', 'Maria', (13, 3, 2003), 'Ivanovna')
reg = register('Ivanov', 'Sergej', (24, 9, 1995), registry=reg)
reg = register('Smith', 'John', (13, 2, 2003), registry=reg)
print(reg)
# [('Petrova', 'Maria', 'Ivanovna', 13, 3, 2003), ('Ivanov', 'Sergej', None, 24, 9, 1995), ('Smith', 'John', None, 13, 2, 2003)]
reg = register('Ivanov', 'Sergej', (24, 13, 1995))
# ValueError: Invalid Date!
```

----

#### **Задание 5.7** ####

Написать бесконечный итератор по списку.    
Для этого создать генератор с названием `inf_iter`, который принимает на вход
список и возвращает элементы из него через `yield`. Когда элементы в списке
заканчиваются, генератор снова возвращает элементы из списка, начиная с
нулевого.    
***Подсказка***    
В теле генератора организовать бесконечный цикл (внутри бесконечного цикла
реализуется цикл `for`). В цикле `for` пройтись по списку и выдавать его
элементы с помощью `yield`. Так получится циклический доступ к элементам списка.

```python
def inf_iter(list_in):
    while True:
        for item in list_in:
            yield item


list_ = [101, 102, 103]
generator_ = inf_iter(list_)
for i_ in range(10):
    print(next(generator_), end=' ')
# 101 102 103 101 102 103 101 102 103 101
```

----

#### **Задание 5.8** ####

Написать генератор `group_gen(n)`. Он должен при каждом вызове выдавать
порядковый номер от 1 до **n** (включая **n**). После достижения **n** генератор
должен снова возвращать номера, начиная с 1.    
***Подсказка***    
В теле генератора организовать бесконечный цикл (внутри бесконечного цикла
реализуется цикл `for`). В цикле `for` пройтись по диапазону от 1 до **n+1** и
выдавать его элементы с помощью `yield`. Так получится циклический доступ к
элементам списка.

```python
def group_gen(n):
    while True:
        for iter in range(1, n+1):
            yield iter


groups = group_gen(3)
for i_ in range(10):
    print(next(groups), end=' ')
# 1 2 3 1 2 3 1 2 3 1
```

----

#### **Задание 6.1** ####

Допустим, надо выгрузить несколько новостей с сайта. Есть список путей до
интересующих статей. Пример такого списка:

```python
docs = [
    '//doc/5041434?query=data%20science',
    '//doc/5041567?query=data%20science',
    '//doc/4283670?query=data%20science',
    '//doc/3712659?query=data%20science',
    '//doc/4997267?query=data%20science',
    '//doc/4372673?query=data%20science',
    '//doc/3779060?query=data%20science',
    '//doc/3495410?query=data%20science',
    '//doc/4308832?query=data%20science',
    '//doc/4079881?query=data%20science'
    ]
```

Как видно, представленные ссылки на статьи неполные&nbsp;&mdash; в них не
хватает адреса самого сайта. Задача&nbsp;&mdash; составить новый список `links`,
в котором будут храниться полные ссылки до статей на сайте
&laquo;Коммерсант&raquo;. Например, полная ссылка до первой статьи будет иметь
вид:    
`https://www.kommersant.ru//doc/5041434?query=data%20science`    
Для решения задачи использовать функцию `map()`. К каждому элементу списка
`docs` применить функцию-преобразование, которая добавляет к ссылке на начальную
страницу сайта путь до статьи из списка `docs`.    
Результат работы функции `map()` обернуть в список и занести в переменную
`links`.    
***Подсказка***    
Первым аргументом функции `map()` указать функцию, которая возвращает сумму
`main_link` и переданного аргумента (результат конкатенации строк).

```python
main_link = 'https://www.kommersant.ru'
links = list(map(lambda doc: main_link + doc, docs))
```

----

#### **Задание 6.2** ####

Задачка для сотрудника отдела разработки в МФЦ. МФЦ предоставляет некоторый
спектр услуг многодетным семьям. Необходимо написать функционал, который
позволяет отфильтровать среди всех запрашиваемых пользователем услуг (их
количество произвольное) только те, которые предоставляются многодетным семьям.    
Список услуг, предоставляемых многодетным семьям:

```text
family_list = [
    'certificate of a large family',
    'social card',
    'maternity capital',
    'parking permit',
    'tax benefit',
    'reimbursement of expenses',
    "compensation for the purchase of children's goods"
    ]
```

Определить функцию `family()`, на вход которой подаётся произвольное количество
аргументов (строки с названием услуг МФЦ), а в результате возвращается список
услуг, которые могут быть оказаны только многодетной семье.    
Для фильтрации входного списка аргументов использовать функцию `filter()`.    
***Подсказка 1***    
Для передачи произвольного количества аргументов в функцию в виде списка
используется `*`:

```text
def family(*arg):
    pass
```

***Подсказка 2***    
В функцию `filter()` передать функцию, которая возвращает `True`, если её
аргумент есть в списке `family_list`, и `False`&nbsp;&mdash; в противном случае.

```python
def family(*services):
    family_list = [
        'certificate of a large family',
        'social card',
        'maternity capital',
        'parking permit',
        'tax benefit',
        'reimbursement of expenses',
        "compensation for the purchase of children's goods"
        ]
    return list(filter(lambda service: service in family_list, services))


print(family('newborn registration',
             'parking permit',
             'maternity capital',
             'tax benefit',
             'medical policy'
            )
    )
#['parking permit', 'maternity capital', 'tax benefit']
```

----

#### **Задание 6.3** ####

Вновь регистрация пользователей. Имеется список кортежей `reg`. В каждом кортеже
хранится информация о зарегистрированном пользователе и его дате рождения в
формате `(Фамилия, Имя, день, месяц, год)`.    
Выбрать из списка `reg` только те записи, в которых год рождения пользователя
2000 и больше (2001, 2002 и т.д.). Из оставшихся записей составить новый список
кортежей, в котором фамилия и имя объединены в одну строку по следующему шаблону
`"Фамилия И."` (внимание на точку после сокращения имени).    
Для решения задачи использовать конвейер из `filter()` и `map()`.    
***Примечание***    
Обратить внимание, что дана двумерная структура, то есть функции фильтрации и
преобразования, указываемые в аргументах в `filter()` и `map()`, принимают на
вход один кортеж и должны обрабатывать его.    
В результате работы программы должен быть создан обновлённый список кортежей с
именем переменной `new_reg`.    
***Подсказка 1***    
Для фильтрации объявить функцию, которая будет возвращать `True`, если последний
элемент входного кортежа больше 2000, и `False`&nbsp;&mdash; в противном случае.
Передать эту функцию в аргументы `filter()` вместе со списком кортежей `reg`.    
***Подсказка 2***    
Для преобразования отфильтрованных записей создать функцию, которая будет
принимать на вход кортеж. В теле этой функции создавать новый кортеж
`(Фамилия И., день, месяц, год)` и возвращать этот кортеж.    
Применить функцию к каждому элементу списка кортежей `reg` с помощью `map()`.

```python
reg = [('Ivanov', 'Sergej', 24, 9, 1995),
       ('Smith', 'John', 13, 2, 2003),
       ('Petrova', 'Maria', 13, 3, 2003),
]
millenials = filter(lambda human: human[4] >= 2000, reg)
new_reg = list(map(lambda person: (f'{person[0]} {person[1][0]}.',
                                    person[2],
                                    person[3],
                                    person[4]
                                  ),
                                  millenials
                  )
              )


print(new_reg)
#[('Smith J.', 13, 2, 2003), ('Petrova M.', 13, 3, 2003)]
```

----

#### **Задание 6.4** ####

Стоит задача разбить пользователей на три группы, чтобы в дальнейшем проводить
А/B/C-тестирование. Например, первой группе выдаётся первый вариант интерфейса
приложения, второй группе&nbsp;&mdash; второй, третьей группе&nbsp;&mdash;
третий. Затем тестировщик будет сравнивать реакцию пользователей и делать вывод,
какой интерфейс лучше.    
Для генерации групп дан генератор `group_gen`. Аргументом данного генератора
является число `n`&nbsp;&mdash; число групп (у нас `n=3`). При каждом вызове
генератора он возвращает число от 1 до `n`. После достижения `n` генератор снова
возвращает номера групп, начиная с 1.    
Пример списка пользователей:    
`users = ['Smith J.', 'Petrova M.', 'Lubimov M.', 'Holov J.']`    
Написать функцию `print_groups`, которая принимает список с именами
пользователей. Используя генератор групп `group_gen`, печатать на экран:    
`<Фамилия И.> in group <номер группы по порядку>`.    
Например, для списка `users` вывод будет таким:

```text
Smith J. in group 1
Petrova M. in group 2
Lubimov M. in group 3
Holov J. in group 1
```

***Указание***    
Используйте функцию `zip()` для одновременной работы со списком и генератором.

```python
def group_gen(n=3):
    while True:
        for iter in range(1, n+1):
            yield iter

def print_groups(users):
    for student, group in zip(users, group_gen()):
        print(student, 'in group', group)


users = ['Smith J.', 'Petrova M.', 'Lubimov M.', 'Holov J.']
print_groups(users)
# Smith J. in group 1
# Petrova M. in group 2
# Lubimov M. in group 3
# Holov J. in group 1
```

----

#### **Задание 7.3** ####

Написать функцию-декоратор-логгер `logger(name)`.    
При создании декоратора передаётся имя логгера, которое выводится при каждом
запуске декорируемой функции.
Декорированная функция должна печатать:

- перед запуском основной:    
    `<имя логгера>: Function <имя декорируемой функции> started`
- после запуска основной:    
    `<имя логгера>: Function <имя декорируемой функции> finished`

***Примечание***    
Узнать имя функции из переменной `func`, переданной в декоратор, можно с помощью
конструкции `func.__name__`. Это так называемые &laquo;магические&raquo;
атрибуты у объектов в Python.

```python
def logger(name):
    def logger_decor(func):
        def func_decor(*args, **kwargs):
            print(f'{name}: Function {func.__name__} started')
            result = func(*args, **kwargs)
            print(f'{name}: Function {func.__name__} finished')
            return result
        return func_decor
    return logger_decor

@logger('MainLogger')
def root(val, n=2):
    return val ** (1/n)


print(root(25))
# MainLogger: Function root started
# MainLogger: Function root finished
# 5.0
```
