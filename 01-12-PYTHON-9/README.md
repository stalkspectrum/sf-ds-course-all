## Задачи из юнитов модуля PYTHON-9 () ##

#### **Задание 2.3** ####

```text
clients = [953421196, 953421161, 953421142, 953421186, 953421181, 953421144, 953421190, 953421184, 953421141, 953421193, 953421129, 953421158, 953421130, 953421177, 953421181, 953421136, 953421160, 953421184, 953421146, 953421175, 953421110, 953421139, 953421100, 953421116, 953421130, 953421179, 953421181, 953421136, 953421174, 953421167, 953421132, 953421195, 953421145, 953421108, 953421143, 953421133, 953421180, 953421149, 953421135, 953421195, 953421143, 953421131, 953421157, 953421189, 953421128, 953421132, 953421127, 953421151, 953421197, 953421160, 953421112, 953421155, 953421182, 953421168, 953421131, 953421156, 953421113, 953421102, 953421113, 953421192, 953421142, 953421105, 953421165, 953421175, 953421102, 953421195, 953421154, 953421165, 953421141, 953421166, 953421126, 953421143, 953421165, 953421150, 953421187, 953421129, 953421176, 953421169, 953421109, 953421177, 953421109, 953421150, 953421136, 953421140, 953421189, 953421198, 953421186, 953421159, 953421184, 953421182, 953421133, 953421103, 953421186, 953421132, 953421121, 953421107, 953421138, 953421190, 953421113, 953421161, 953421154, 953421161, 953421107, 953421113, 953421180, 953421191, 953421178, 953421116, 953421102, 953421167, 953421191, 953421187, 953421182, 953421118, 953421122, 953421157, 953421195, 953421141, 953421116, 953421176, 953421194, 953421163, 953421116, 953421197, 953421189, 953421177, 953421133, 953421138, 953421101, 953421116, 953421128, 953421104, 953421165, 953421113, 953421135, 953421150, 953421165, 953421154, 953421165, 953421161, 953421188, 953421177, 953421189, 953421128, 953421116, 953421177, 953421147, 953421152, 953421175, 953421151, 953421183, 953421195, 953421142, 953421132, 953421148, 953421112, 953421111, 953421121, 953421125, 953421171, 953421169, 953421127, 953421191, 953421194, 953421114, 953421112, 953421142, 953421144, 953421176, 953421120, 953421134, 953421183, 953421140, 953421144, 953421172, 953421189, 953421143, 953421188, 953421176, 953421142, 953421117, 953421140, 953421155, 953421158, 953421131, 953421187, 953421156, 953421120, 953421118, 953421184, 953421171, 953421186, 953421115, 953421101, 953421124, 953421151, 953421153, 953421141, 953421156, 953421144, 953421135, 953421109, 953421177, 953421144, 953421109, 953421148, 953421144, 953421111, 953421161, 953421133, 953421144, 953421118, 953421137, 953421182, 953421111, 953421178, 953421100, 953421160, 953421175, 953421171, 953421149, 953421156, 953421187, 953421198, 953421117, 953421100, 953421167, 953421118, 953421136, 953421101, 953421163, 953421133, 953421133, 953421136, 953421116, 953421141, 953421163, 953421152, 953421193, 953421197, 953421142, 953421172, 953421152, 953421190, 953421193, 953421102, 953421149, 953421117, 953421160, 953421161, 953421147, 953421170, 953421161, 953421147, 953421172, 953421174, 953421168, 953421121, 953421190, 953421162, 953421173, 953421110, 953421111, 953421154, 953421157, 953421161, 953421179, 953421191, 953421155, 953421139, 953421180, 953421189, 953421155, 953421109, 953421169, 953421174, 953421192, 953421104, 953421116, 953421112, 953421151, 953421169, 953421149, 953421176, 953421102, 953421136, 953421146, 953421152, 953421146, 953421152, 953421116, 953421108, 953421183, 953421128, 953421150, 953421158, 953421194, 953421136, 953421104, 953421139]
```

Из списка карт постоянных покупателей `clients` выбрать номер карты наиболее
частого клиента.

```python
from collections import Counter

cards = Counter(clients)
print(cards.most_common()[0])
# (953421116, 9)
print(cards.most_common()[0][0])
# 953421116
```

----

#### **Задание 2.4** ####

Сколько раз был в магазине покупатель с картой под номером `953421102`?

```python
print(cards[953421102])
# 5
```

----

#### **Задание 2.5** ####

Сколько уникальных номеров карт содержит список `clients`?

```python
print(len(list(cards)))
# 94
```

----

#### **Задание 3.2** ####

```text
temps = [('2000', -4.4), ('2001', -2.5), ('2002', -4.4), ('2003', -9.5),
        ('2004', -8.2), ('2005', -1.6), ('2006', -5.9), ('2007', -2.4),
        ('2008', -1.7), ('2009', -3.5), ('2010', -12.1), ('2011', -5.8),
        ('2012', -4.9), ('2013', -6.1), ('2014', -6.9), ('2015', -2.7),
        ('2016', -11.2), ('2017', -3.9), ('2018', -2.9), ('2019', -6.5),
        ('2020', 1.5)]
```

Дан список из кортежей `temps`. На первом месте в кортеже указан год в виде
строки, а на втором&nbsp;&mdash; средняя температура января в Петербурге в
указанном году.    
Необходимо напечатать словарь, в котором ключи&nbsp;&mdash; годы, а
значения&nbsp;&mdash; - показатели температуры. Ключи необходимо отсортировать в
порядке убывания соответствующих им температур.    
***Пример входа:***    
`temps =  [('2000', -4.4), ('2001', -2.5), ('2002', -4.4), ('2003', -9.5)]`    
***Пример вывода:***    
`OrderedDict([('2001', -2.5), ('2000', -4.4), ('2002', -4.4), ('2003', -9.5)])`

```python
from collections import OrderedDict

temps.sort(key=lambda x: x[1], reverse=True)
temp_dict = OrderedDict(temps)
print(temp_dict)
```

----

#### **Задание 4.3** ####

Написать функцию `brackets(line)`, которая определяет, является ли
последовательность из круглых скобок правильной. Правильной скобочной
последовательностью называется такая последовательность скобок, в которой для
каждой открывающей скобки есть последующая соответствующая ей закрывающая
скобка. Пустую строку считать правильной последовательностью.    
Для решения этой задачи потребуется использовать стек. Посимвольно перебрать
строку. Если встретилась открывающаяся скобка, положить её в стек. Если
встретилась закрывающаяся скобка, извлечь скобку из стека.

1. Если стек пустой, то есть извлечь скобку нельзя, последовательность
неправильная.
2. Если строка закончилась и стек стал пустым, последовательность правильная.
3. Если в стеке остались скобки, последовательность неправильная.

```python
from collections import deque

def brackets(line):
    queue = deque()
    for char in line:
        if char == '(':
            queue.append('(')
        if char == ')':
            if queue.count('(') > 0:
                queue.remove('(')
            else:
                return False
    if len(queue) == 0:
        return True
    return False
```

----

#### **Задание 4.10** ####

Написать функцию `task_manager(tasks)`, которая принимает список задач для
нескольких серверов. Каждый элемент списка состоит из кортежа (&lt;номер
задачи&gt;, &lt;название сервера&gt;, &lt;высокий приоритет задачи&gt;).    
Функция должна создавать словарь и заполнять его задачами по следующему
принципу: название сервера&nbsp;&mdash; ключ, по которому хранится очередь задач
для конкретного сервера.    
Если поступает задача без высокого приоритета (последний элемент кортежа&nbsp;&mdash;
`False`), добавить номер задачи в конец очереди. Если приоритет высокий,
добавить номер в начало.    
Для словаря использовать `defaultdict`, для очереди&nbsp;&mdash; `deque`.
Функция возвращает полученный словарь с задачами.    
***Пример***    

```text
tasks = [(36871, 'office', False),
(40690, 'office', False),
(35364, 'voltage', False),
(41667, 'voltage', True),
(33850, 'office', False)]
```

```python
from collections import defaultdict, deque

def task_manager(tasks):
    task_dict = defaultdict(deque)
    for task in tasks:
        ident, server, urgent = task
        if urgent:
            task_dict[server].appendleft(ident)
        else:
            task_dict[server].append(ident)
    return task_dicr


print(task_manager(tasks))
# defaultdict(, {'voltage': deque([41667, 35364]), 'office': deque([36871, 40690, 33850])})
```

----
